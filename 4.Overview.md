#ECMA-262 第五版/ December 2009
##ECMAScript 语言规范

###第四章 概述

这一章包含的是对于ECMAScript语言的非正式概述。
ECMAScript是一种面向对象的语言，主要用来在可运行的环境里进行计算，以及处理可计算的对象。此处定义的ECMAScript并非是完整的语言；事实上，我们对于所有的外部输入数据和输出计算结果没有给出任何规定。相反的，我们希望一个能运行ECMAScript程序的运行环境不光能提供这篇规范里提到的对象和组件，还能提供特殊的与环境相关的__宿主__(host)对象，它们的描述和行为都不在这篇规范的叙述范围之内，不过本文会提到它们应该提供特定的属性和方法可以让一个ECMAScript程序访问到。
一个脚本语言是用来处理，自定义以及自动化现有系统组件的语言。在这样的系统里，已经有现成的功能组件可以通过用户接口访问到，而脚本语言则是将这些功能释放到可由程序控制的层面。而这样一个环境，我们将之称为提供了对象和组件的宿主环境，它让脚本语言的功能变得完善。脚本语言同时面向专业程序员和非专业程序员。
ECMAScript从最初就被设计为一种__网页脚本语言__(Web scripting language)，用来提供一些可以让浏览器中的网页更生动的机制，同时还能在【客户端-服务器】架构中展示服务端的计算结果。ECMAScript能给不同的宿主环境提供一些核心的脚本功能，因此本篇规范中将对这部分核心功能给出与环境无关的明确定义。
ECMAScript中的部分组件和其他语言里的定义十分类似；尤其是Java，Self和Scheme，它们的描述分别在以下文档中：

>Gosling, James, Bill Joy and Guy Steele. The Java™ Language Specification. Addison Wesley Publishing Co., 1996.
>Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA ’87 Conference Proceedings, pp. 227-241, Orlando, FL, October 1987.
>IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.

####4.1 网页脚本
一个网页浏览器提供了ECMAScript的宿主环境以进行客户端运算。比方说，它提供了代表窗口，菜单，弹出窗口，对话框，文本区域，锚点，框架，历史，cookies以及输入输出的对象。更进一步，宿主环境还提供了将脚本语言和事件进行绑定的机制，这些事件包括焦点的变换，页面和图片的载入，上传，错误和中断，选择，表单的提交，以及鼠标的动作。脚本语言会在HTML中间出现，而呈现的页面则是用户界面元素和修正、计算过的文字图片的组合。脚本语言可以对用户的操作进行交互，也因此并不需要一个主程序。
一个网页服务端则提供了另一种针对服务端运算的宿主环境，包括了代表请求，客户端，文件的对象；以及共享数据和加锁机制。同时使用这两类脚本，可以将服务端和客户端的运算分离，并且为一个基于网页的应用提供用户界面。
每个网页浏览器和服务器都提供了它们自己的ECMAScript环境，使得整个ECMAScript执行环境得以完善。

####4.2 语言概述
接下来是关于ECMAScript的非正式概述——并非这个语言的所有部分都会被涉及到。这份概述也并不是标准里的一部分。
ECMAScript是基于对象的：最基本的语言和宿主组件都是由对象提供的，并且ECMAScript程序可以看做是很多可以进行运算的对象的集群。一个ECMAScript对象(object)是由一组__属性__(property)组成的，并且每个属性都有零或多个决定属性能如何被使用的__特征__(attribute)组成的——比方说，当一个属性的可写(Writable)特征被设为false的时候，任何企图更改这项属性的操作都将失败。属性是用来存放其他对象的容器，比如__原生类型值__(primitive value)或__函数__(function)。一个原生类型值是如下类型中的一种：__未定义__(Undefined)，__空值__(Null)，__布尔值__(Boolean)，__数值__(Number)和__字符串__(String)；一个对象则属于剩下的内置类型：__对象__(Object)；函数则是可以被调用的对象。一个和对象关联起来的函数被称之为__方法__(method)。
ECMAScript定义了一组内置对象来完善自身。这些内置对象包括：__全局__(global)对象，__Object__对象，__函数__(Function)对象，__数组__(Array)对象，__字符串__(String)对象，__布尔值__(Boolean)对象，__数值__(Number)对象，__数学__(Math)对象，__日期__(Date)对象，__正则表达式__(RegExp)对象，__JSON__对象，以及错误对象，包括__Error__，__EvalError__，__RangeError__，__ReferenceError__，__SyntaxError__，__TypeError__和__URIError__。
ECMAScript还定义了一组内置__运算符__(operator)。ECMAScript运算符包括了很多非一元运算符，乘法、加法运算符，按位位移运算符，关系运算符，等值运算符，二进制位运算符，二进制逻辑运算符，赋值运算符和逗号运算符。
ECMAScript语法被特意设计成类Java的。为了使ECMAScript成为一种易于使用的脚本语言，它的语法被设计得较为宽松。比如说，一个变量在声明的时候不需要指出其类型，或其属性的类型，函数的定义也不要求一定要在调用它之前。

#####4.2.1 对象
ECMAScript并没有使用类似C++，Smalltalk或者Java里的类。取而代之的，ECMAScript里的对象可以通过多种方式创建，比如直接通过[对象构造语法](https://www.evernote.com/shard/s328/sh/36cfb8ef-8bfc-4101-80ef-9a9aa6756027/98d193809bff8f6cc5f966ddcaf3f7d4)进行构造，又或者通过__构造器__(constructor)构造。构造器可以创建对象，并且通过对对象的部分或全部属性赋予初值来将其初始化。每一个构造器都是一个函数，并且有一个叫做“__原型__(protorype)”的属性，这个属性是用来实现__基于原型的继承__(prototype-based inheritance)和__属性共享__(shared properties)的。对象可以通过对构造器使用__new__语句创建；比如说new Date(2009, 11)创建了一个Date对象。仅仅调用构造器而不使用new语句的结果因构造器的不同而异。举例来说，Date()会产生一个代表当前日期和时间的字符串，而不是一个Date对象。
每一个被构造器创建的对象都有一个隐含的指向构造器“原型”属性的引用(称之为这个对象的原型)。更进一步，一个原型还可能有一个非空的引用指向这个原型的原型，依此类推；这被称为_原型链_(prototype chain)。如果一个对象的某个属性被引用，那么这个引用会查找原型链中第一个拥有相同属性的原型。换句话说，首先会检查这个对象是否有这个属性；如果有，则直接引用这个属性；不然则查找它的原型；依此类推。

在基于类的面向对象语言里，一般来说，状态被存储在实例中，方法则由类决定，继承仅仅决定结构和行为。在ECMAScript中，状态和方法都由对象携带，结构、行为、状态全都可以继承。
![Figure 1](https://raw.github.com/tinyx/ECMAScript-Specification-5th-CN/master/images/1.png "Figure 1")

只要一个对象没有包含它的原型所包含的属性，那它就和它的原型共享这个属性。以图1为例：
CF是一个构造器(同时也是一个对象)。五个对象分别使用new语句构造并依此命名为cf1，cf2，cf3，cf4和cf5。每个对象都有q1和q2两个属性。虚线表示的是隐含的原型关系；举例来说，cf3的原型是CFp。构造器CF有自己有P1和P2两个属性，这对于CFp，cf1，cf2，cf3，cf4和cf5来说都是不可见的。但由于指向CFp的原型链里CFP1、q1、q2属性没有重复冲突，所以CFP1属性可以与cf1，cf2，cf3，cf4和cf5共享(但不与CF共享)。我们可以注意到CF和CFp之间并没有隐含的原型引用。
不同于基于类的面向对象语言，属性可以动态地赋予到对象上。这意味着构造器并不一定要在初始化的时候给对象的全部属性赋值。在上面的图表中，只要给CFp对象赋予一个新的属性，cf1——cf5都将可以访问到这个共享的属性。

#####4.2.2 ECMAScript的严格变种
ECMAScript语言意识到部分用户可能希望对于这个语言特性的使用用例能够更加严格。也许是处于对安全的考虑，也许是为了避免易出错的特性，也许是为了更好的进行错误检查，当然还可能是处于其他考虑。对于这样的需求，ECMAScript定义了严格变种。严格模式去掉了部分常规ECMAScript语言的语法和句法特性，并且修改了部分特性的细节。严格模式还增加了额外的错误，在以往并不认为是错误的情形中，用户可以通过抛出特定的异常来处理这部分错误。
ECMAScript的严格变种一般是指这个语言的_严格模式_(strict mode)。严格模式的开启与关闭，语法与语义的不同都体现在单个ECMAScript代码单元中。因为这样，严格模式的开启与关闭只影响单个的代码单元。对于需要跨单元执行的代码，严格模式并不生效。所以对于一个完整的ECMAScript程序，由于其可能是由严格模式和非严格模式的单元组成，严格模式仅仅对局限在一个严格模式单元中的代码部分生效。
为了满足严格模式，ECMAScript的实现必须包括完整的非严格模式ECMAScript语言和严格变种。更进一步，这个实现必须包含对非严格模式和严格模式组合使用的支持。

####4.3 定义
下面给出这篇文档需要用到的名词的定义。

#####4.3.1 类型(type)
在第八章定义的数据取值的集合。

#####4.3.2 原生类型值(primitive value)
如下类型中的一种：__未定义__(Undefined)，__空值__(Null)，__布尔值__(Boolean)，__数值__(Number)和__字符串__(String)。

注：原生类型值是在语言实现最底层用来表示数据的类型。

#####4.3.3 对象(object)
类型Object的成员。

注：一个对象是一组属性和一个原型对象的组合。原型对象可以是空值。

#####4.3.4 构造器(constructor)
可以创建并初始化对象的函数对象。

注：构造器的“__原型__”属性是用作继承和实现属性共享的。

#####4.3.5 原型(prototype)
为其他对象提供共享属性的对象。

注：当构造器创建一个对象的时候，为了解决属性的引用问题，这个对象会隐式引用这个构造器的“__原型__”属性。构造器的“__原型__”属性可以通过_构造器_.__原型__引用，对构造器的原型对象添加的属性也会共享给其他引用该原型的所有对象。构造对象的另一种方法是调用Object.create方法。

#####4.3.6 原生对象(native object)
在本篇规范中已经被完整地定义过的对象。

注：标注的原生对象在本篇规范中已经完整的定义过了。部分对象已经内置，另一部分会在运行ECMAScript程序的过程中被创建。

#####4.3.7 内置对象(built-in object)
ECMAScript实现中包含的对象，它们独立于宿主环境，在ECMAScript程序执行之前就已经创建。

注：标准的内置对象在本篇规范中已经定义，而且不同的ECMAScript实现也许会定义其他的内置对象。每一个内置对象都是原生对象。内置构造器既是内置对象也是构造器。

#####4.3.8 宿主对象(host object)
宿主环境为了完整地支持ECMAScript的运行定义的对象。

注：所有非原生对象都是宿主对象。

#####4.3.9 未定义值(undefined value)
当一个变量未被赋值是使用的原生变量值。

#####4.3.10 未定义类型(Undefined type)
值为未定义(undefined)的变量类型

#####4.3.11 空值(null value)
代表有意留空的原生变量值。

#####4.3.12 空类型(Null type)
值为空值(null)的变量类型

#####4.3.13 布尔值(Boolean value)
布尔类型的成员。
注：它有且仅有两个值，true和false。

#####4.3.14 布尔类型(Boolean type)
值为true或false的变量类型。

#####4.3.15 布尔对象(Boolean object)
由内置的布尔对象构造器构造的对象。

注：一个布尔对象是通过对布尔构造器使用new表达式创建的，支持使用布尔值作为参数。生成的布尔对象含有一个内置属性存储这个值。布尔对象可以被强制转换为布尔值。

#####4.3.16 字符串变量(String value)
有限、有序的列表，包含了0个或多个16位无符号整数。

注：一个字符串变量是字符串类型(String type)的成员。在这个列表中的每一个16位整数表示了一个UTF-16文本。然而，ECMAScript并没有给出任何对这些整数的限制——只要它们只16位无符号整数。

#####4.3.17 字符串类型(String type)
所有可能的字符串值的集合。

#####4.3.18 字符串对象(String object)
由内置的字符串对象构造器创建的对象。

注：一个字符串对象是通过对字符串构造器使用new表达式创建的，支持使用字符串值作为参数。生成的字符串对象含有一个内置属性存储这个值。直接将字符串构造器作为函数使用则可以将字符串对象强制转换为字符串值。

#####4.3.19 数值(Number value)
64位双精度浮点数值，遵循IEEE 754格式。

注：一个数值是数值类型的一个成员，可以直接表示一个数字。

#####4.3.20 数值类型(Number type)
所有数值的集合，包括“非数字NaN”，“正无穷大”和“负无穷大”。

#####4.3.21 数值对象(Number object)
所有由内置的数值构造器创建的对象。

注：一个数值对象是通过对数值构造器使用new表达式创建的，支持使用数值作为参数。生成的数值对象含有一个内置属性存储这个值。直接将数值构造器作为函数使用则可以将数值对象强制转换为数值。

#####4.3.22 无穷大(Infinity)
表示正无穷大的数值。

#####4.3.23 非数字(NaN)
在IEEE 754规范中定义的非数字值(Not-a-Number)
#####4.3.24 函数(function)
所有由内置的函数构造器创建的对象，可以作为一个子程序被调用。

注：它除了有命名过的属性外，还包括可执行的代码以及决定它如何执行的状态量。函数的代码不一定是用ECMAScript编写的。

#####4.3.25 内置函数(built-in function)
是函数的内置对象。

注：内置函数的例子包括parseInt和Math.exp。不同的实现可能会包含这篇规范不曾定义的内置函数。

#####4.3.26 属性(property)
一个对象的一组值，包括属性名和属性值。

注：对象的属性值可以是直接定义的数据值(原生类型值，对象，函数对象)，也可以是间接定义的一对用来访问属性的函数(get，set函数)。

#####4.3.27 方法(method)
一个属性的值是一个函数，则这个函数被称之为方法。

注：当一个函数作为一个对象的方法被调用的时候，这个对象会被传递给这个函数的__this__变量。

#####4.3.28 内置方法(built-in method)
是内置函数的方法。

注：标准的内置方法在这篇规范中已经定义，并且ECMAScript还可能定义和提供其他额外的内置方法。

#####4.3.29 特征(attribute)
用来定义属性使用特性的内置值。

#####4.3.30 自有属性(own property)
对象直接包含的属性。

#####4.3.31 继承属性(inherited property)
对象自身不具有的属性，但是可以在原型链中的某一个原型里获取到的属性。

